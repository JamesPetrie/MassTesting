---
title: "Non-pharmaceutical interventions for respiratory pandemics: challenges and a potential solution"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
require(data.table)
require(ggplot2)
require(cowplot)

theme_set(theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank()) + theme(legend.background = element_rect(fill = "white")) + theme_half_open() + background_grid()  + theme(text = element_text(size=20), axis.text = element_text(size=20)))
```



# frequent testing


Fraction of transmissions after receiving positive test as function of frequency and delay for Covid
```{r}
# uses results from ~/MassTesting/testDetect.jl
dt = fread("~/MassTesting/FracTransmissions.csv")
dt[, TestDelay := as.factor(TestDelay)]
ggplot(dt, aes(x = TestPeriod, y = FracAfterPositive, colour = TestDelay)) + geom_line() + geom_point() + scale_x_continuous(expand = c(0, 0), limits = c(0,10), breaks = seq(0,10)) + scale_y_continuous(expand = c(0, 0), limits = c(0,1)) + guides(colour=guide_legend(title="Test Delay [Days]")) + xlab("Testing Period [Days]") + ylab("Fraction Counterfactual Transmissions \n After Receiving Positive Test")+ theme(legend.position = c(0.6, 0.8)) + theme(text = element_text(size=16))
```


Useful to construct a very simplified mathematical model of the strategy to make explicit our assumptions and quantitively analyse points of failure. For simplicity, will only consider this strategy and not combinations of them. 

In a homogeneous population where fraction $\gamma$ test regularly, fraction $\sigma$ of counterfactual transmissions occur after receiving a positive test (depending on frequency, delay, and relationship between test sensitivity and infectiousness), and transmissions are reduced to fraction $\beta$ after receiving a positive test, the following equation gives the effective reproductive number.

$R_e = R_0 (1 - \gamma \sigma \beta)$


```{r}
R0 = 2.5

ausIsoEffect = 0.9939



dt[, Label := paste0("Period=", TestPeriod,", Delay=",TestDelay)]
dtRe = data.table(expand.grid(FracTest = seq(0.5,1, length.out=200), Label = dt$Label))

dtRe = merge(dt, dtRe, by = "Label")

dtRe[, IsoEffect := (1-1/R0)/(FracAfterPositive*FracTest)]
dtRe[IsoEffect > 1, IsoEffect := NA]


showLabels = dt[(TestPeriod == 1 & TestDelay == 0)|
                     (TestPeriod == 1 & TestDelay == 1)|
                     (TestPeriod == 2 & TestDelay == 1)|
                     (TestPeriod == 3 & TestDelay == 1)|
                     (TestPeriod == 7 & TestDelay == 2), 
                Label]

ggplot(dtRe[Label %in% showLabels],aes(x = FracTest, y = IsoEffect, colour = Label)) + geom_line() + scale_x_continuous(limits= c(0.6,1), n.breaks = 10) + scale_y_continuous(limits= c(0.6,1), n.breaks = 10 ) + geom_hline(yintercept = ausIsoEffect) #+ geom_text(aes(0.6, ausIsoEffect, label = "Effectiveness of State Quarantine in Australia", vjust = - 1))

# 1/2.5 = 1 - g*s*b
# g = (1-1/2.5)/(s*b)





```




partial contact tracing:

simple version is assume independence, but people who transmit likely transmit early, so have short incub? correlated?

monte carlo branching model. sample testing offset from infection, sample incubation, sample test results, sample transmissions, sample incubation of infectees, sample testing offset, sample infectee test results. sum expected second degree transmissions.

Track number of second degree infections. Average should be Re^2 ?





# Cost

```{r, echo=FALSE}

fracDt = fread("~/MassTesting/FracTransmissions.csv")



# isoCost = 10*(100 + 200) + 0.5*3000 
computeCost = function(importRate = 1e-4 , R0 = 2.0, testFraction = 0.95, isoFraction = 0.9, testPeriod = 2, testDelay = 1, poolSize = 1, incentiveCost = 10,  logisticCost = 5, pcrCost = 40, isoCost = 5000){
  transFraction = fracDt[TestPeriod == testPeriod & TestDelay == testDelay, FracAfterPositive]
  
  testFreq = 1/testPeriod
  
  
  
  
  Rt = R0*(1 - testFraction*transFraction*isoFraction)
  
  if(Rt > 1) return(1)
  
  newInfectFrac = importRate*1/(1-Rt) # fraction new infections (import and transmit per day) relative to total pop
  
  if(poolSize == 1){
    testCost = testFreq*testFraction*(incentiveCost + logisticCost + pcrCost)
  }else{
    testCost = testFreq*testFraction*(incentiveCost + logisticCost + 1/poolSize*pcrCost + poolSize*newInfectFrac*pcrCost)
  }
  
  dailyCostPerPerson = testCost + newInfectFrac*testFraction*isoCost
  gdpPerCapita = 70e3 # gdp per person in USA
  return(dailyCostPerPerson*365/gdpPerCapita)
}

```


# Cost vs import rate basic
```{r}
R0 = 2

dt = data.table(expand.grid(ImportRate = 10^seq(-9, -2, length.out = 200), TestPeriod  = seq(0:4), TestDelay = 1))
dt$Cost = sapply(1:nrow(dt), function(i){
  computeCost(importRate = dt[i, ImportRate], R0 = R0, testPeriod = dt[i,TestPeriod], testDelay = dt[i,TestDelay] )
} )

ggplot(dt,aes(x= ImportRate, y = Cost, colour = as.factor(TestPeriod))) + geom_line() + scale_x_log10()+scale_y_log10(limits = c(0.01, 0.5), n.breaks = 8)
```


With a PCR cost of \$40 per test, and \$10 incentive, testing everyone every 2 days with a 1 day test delay costs about 12\% of GDP when importation rate below 1e-4. This cost is dominated by the cost of testing. Only when imporation rate exceeds 1e-4 (in this scenario) that cost of incentivizing and supporting isolation becomes significant. 



12\% GDP worthwhile for deadly pandemic, but quite dificult to mobilize, and harder to make the case for apparently less severe pandemics. Can we reduce this cost?


focus on convenience of intervention so cost of point of indifference drops from \$10 to \$5. 
use tests that are more comfortable so price point of indifference lower (saliva rather than nasal)


pooled testing used in many places [] during Covid, but there was limited time to develop optimized systems and the disease prevalence was quite high, so many tests had to be repeated [], increasing the complexity and reducing cost saving from pooled testing

however, in a well-controlled pandemic, the disease prevalence would be so low that the fraction of repeated tests would be insignificant

Testing cost = (1/20 pcrCost  + 20 FracPositive * pcrCost + transportationCost + incentiveCost) * numTests
along with additional 4 hour delay, and slightly reduced sensitivity []

fracPositive less than importRate*1/(1-Rt) = R0*1/(1 - testFraction*transFraction*isoFraction)


#cost vs import rate with pooled testing and realisticly cheaper steps
```{r}
R0 = 2

dt = data.table(expand.grid(ImportRate = 10^seq(-9, -2, length.out = 200), TestPeriod  = seq(0:4), TestDelay = 1))
dt$Cost = sapply(1:nrow(dt), function(i){
  computeCost(importRate = dt[i, ImportRate], R0 = R0, testPeriod = dt[i,TestPeriod], testDelay = dt[i,TestDelay], incentiveCost = 5, logisticCost = 3, poolSize = 32, pcrCost = 40, isoCost = 5e3 )
} )

ggplot(dt,aes(x= ImportRate, y = Cost, colour = as.factor(TestPeriod))) + geom_line() + scale_x_log10() +scale_y_log10(limits = c(0.01, 0.5), n.breaks = 8) #+ylim(0,0.3)
```

pooled testing to bring pcr cost down from \$40 to \$5 or less. 
with \$10 per test would be 2.4\% GDP - much closer to being an easy choice.






